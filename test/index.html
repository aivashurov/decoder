<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–î–µ—à–∏—Ñ—Ä–æ–≤—â–∏–∫ —Å–∏—Å—Ç–µ–º–æ–∫</title>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 900px; margin: auto; }
    textarea { width: 100%; height: 150px; font-family: monospace; font-size: 14px; }
    button { padding: 10px 20px; font-size: 14px; margin-top: 10px; margin-right: 10px; }
    pre { background: #f0f0f0; padding: 15px; white-space: pre-wrap; border: 1px solid #ccc; }

    /* —Ç—ë–º–Ω–∞—è —Ç–µ–º–∞ */
    body.dark-mode {
      background-color: #121212;
      color: #eee;
    }
    body.dark-mode input,
    body.dark-mode textarea,
    body.dark-mode pre#output {
      background-color: #1e1e1e;
      color: #fff;
      border: 1px solid #444;
    }
    body.dark-mode button {
      background-color: #2c2c2c;
      color: #eee;
      border: 1px solid #555;
    }
    body.transition, body.transition * {
      transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }
    .dark-toggle {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 14px;
      cursor: pointer;
      padding: 6px 12px;
      border-radius: 6px;
      background: #333;
      color: #eee;
      border: 1px solid #666;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <button id="theme-toggle" class="dark-toggle" onclick="toggleDarkMode()">
    üåô –¢—ë–º–Ω–∞—è —Ç–µ–º–∞
  </button>
  <script>
    function toggleDarkMode() {
      document.body.classList.add('transition');
      const isDark = document.body.classList.toggle('dark-mode');
      localStorage.setItem('theme', isDark ? 'dark' : 'light');
      updateToggleIcon(isDark);
      setTimeout(() => document.body.classList.remove('transition'), 300);
    }
    function updateToggleIcon(isDark) {
      const btn = document.getElementById('theme-toggle');
      btn.innerHTML = isDark ? '‚òÄÔ∏è –°–≤–µ—Ç–ª–∞—è —Ç–µ–º–∞' : 'üåô –¢—ë–º–Ω–∞—è —Ç–µ–º–∞';
    }
    window.addEventListener('DOMContentLoaded', () => {
      const savedTheme = localStorage.getItem('theme');
      const isDark = savedTheme === 'dark';
      if (isDark) document.body.classList.add('dark-mode');
      updateToggleIcon(isDark);
    });
  </script>

  <h2>–î–µ—à–∏—Ñ—Ä–æ–≤—â–∏–∫ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π 2.0</h2>
  <textarea id="input" placeholder="–í—Å—Ç–∞–≤—å —Å–∏—Å—Ç–µ–º–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ‚Ä¶"></textarea><br />
  <button onclick="decode()">–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
  <button onclick="copyResult()">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
  <button onclick="clearAll()">–û—á–∏—Å—Ç–∏—Ç—å</button>
  <pre id="output"></pre>

<script>
let airports = {};
let aliasMap = {};
let statuses = {};

function isCyrillic(str) {
  return /[–ê-–Ø–Å–∞-—è—ë]/.test(str);
}
function normalizeCyrillic(str) {
  return str
    .replace(/C/g, "–°").replace(/A/g, "–ê")
    .replace(/E/g, "–ï").replace(/O/g, "–û")
    .replace(/K/g, "–ö").replace(/M/g, "–ú")
    .replace(/H/g, "–ù").replace(/X/g, "–•");
}
function fetchCSV(url) {
  return fetch(url)
    .then(res => res.text())
    .then(text => {
      const lines = text.trim().split(/\r?\n/);
      const [hdr, ...rows] = lines;
      const keys = hdr.split(',');
      return rows.map(r => {
        const vals = r.split(',');
        const obj = {};
        keys.forEach((k,i) => { obj[k.trim()] = (vals[i]||"").trim(); });
        return obj;
      });
    });
}

function init() {
  Promise.all([
    fetchCSV("https://raw.githubusercontent.com/aivashurov/decoder/refs/heads/main/airports_cleaned.csv?v="+Date.now()),
    fetchCSV("https://raw.githubusercontent.com/aivashurov/decoder/refs/heads/main/statuses_cleaned.csv?v="+Date.now())
  ]).then(([airportData, statusData]) => {
    airportData.forEach(a => {
      airports[a.code] = { city: capitalize(a.city), iata: a.iata };
      if (a.alias) {
        a.alias.split(' ')
          .map(x=>x.trim()).filter(x=>x)
          .forEach(alias => {
            const norm = isCyrillic(alias) ? normalizeCyrillic(alias) : alias;
            aliasMap[norm.toUpperCase()] = a.code;
          });
      }
    });
    // ---- –∑–¥–µ—Å—å –∑–∞—â–∏—â—ë–Ω–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ —Å—Ç–∞—Ç—É—Å–æ–≤ ----
    statusData.forEach(s => {
      if (s && s.code) {
        const code = s.code.trim().toUpperCase();
        statuses[code] = (s.description||"").trim();
      }
    });
  }).catch(err => {
    document.getElementById("output").textContent = "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö: " + err;
  });
}

function capitalize(str) {
  return str
    ? str.split(/([ -])/g).map(w =>
        /[–ê-–ØA-Z–Å]/i.test(w.charAt(0))
          ? w.charAt(0).toUpperCase() + w.slice(1)
          : w
      ).join('')
    : '';
}

function matchRoute(rt) {
  for (let len=3; len<=4; len++) {
    const f = rt.slice(0,len), t = rt.slice(len);
    const fm = aliasMap[f]|| (airports[f]?f:null);
    const tm = aliasMap[t]|| (airports[t]?t:null);
    if (fm && tm) return [fm,tm];
  }
  return [null,null];
}

function preprocessGDS(line) {
  return line
    .replace(/[.,#]/g, '')
    .replace(/\s+O\*/g, '')
    .replace(/\s+E\b/g, '')
    .replace(/\b([A-Z0-9]{2})(\d{3,4}[A-Z]?)\b/g, '$1-$2');
}

function extractDays(line) {
  const daysMap = { MO:"–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫",TU:"–≤—Ç–æ—Ä–Ω–∏–∫",WE:"—Å—Ä–µ–¥–∞",TH:"—á–µ—Ç–≤–µ—Ä–≥",
                    FR:"–ø—è—Ç–Ω–∏—Ü–∞",SA:"—Å—É–±–±–æ—Ç–∞",SU:"–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ" };
  const m = line.match(/\b(?:MO|TU|WE|TH|FR|SA|SU)(?:\/(?:MO|TU|WE|TH|FR|SA|SU))*\b/);
  if (!m) return "";
  return m[0].split('/').map(d=>daysMap[d]||d).join(', ');
}

function decode() {
  const text = preprocessGDS(document.getElementById("input").value.trim());
  const out = [], lines = text.split(/\n+/);
  for (let line of lines) {
    const toks = line.trim().toUpperCase().split(/\s+/)
      .filter(t=>!/^\d$/.test(t) && !["*",".",","].includes(t));

    // –Ω–∞—Ö–æ–¥–∏–º –∞–≤–∏–∞–∫–æ–º–ø–∞–Ω–∏—é + –Ω–æ–º–µ—Ä
    const cleaned = toks.filter(t =>
      !/^\d{1,2}$/.test(t) &&
      !["*",".","O","E","SU","MO","TU","WE","TH","FR","SA","–±–µ–∑","–∏–∑–º–µ–Ω–µ–Ω–∏–π","–æ—Ç–º–µ–Ω—ë–Ω","–ø—Ä–µ–¥–ª–æ–∂–µ–Ω","–∏–∑–º–µ–Ω–µ–Ω–∏–µ"].includes(t)
    );
    let airline="", flight="";
    for (let i=0; i<cleaned.length-1; i++) {
      if (/^[A-Z0-9]{2}$/.test(cleaned[i]) &&
          /^[0-9]{2,4}[A-Z]?$/.test(cleaned[i+1])) {
        airline = cleaned[i];
        flight  = cleaned[i+1];
        break;
      }
    }
    if (!airline && /^[A-Z0-9]{2}-[0-9]{2,4}$/.test(cleaned[0])) {
      [airline,flight] = cleaned[0].split("-");
    }

    // –¥–∞—Ç–∞
    const dateToken = toks.find(t=>/^\d{2}[A-Z–ê-–Ø–Å]{3}(?:\d{2})?$/i.test(t))||"";
    const months = {
      "–Ø–ù–í":"01","–§–ï–í":"02","–ú–ê–†":"03","–ê–ü–†":"04","–ú–ê–ô":"05","–ò–Æ–ù":"06",
      "–ò–Æ–õ":"07","–ê–í–ì":"08","–°–ï–ù":"09","–û–ö–¢":"10","–ù–û–Ø":"11","–î–ï–ö":"12",
      "JAN":"01","FEB":"02","MAR":"03","APR":"04","MAY":"05","JUN":"06",
      "JUL":"07","AUG":"08","SEP":"09","OCT":"10","NOV":"11","DEC":"12"
    };
    let formattedDate = "‚ö†Ô∏è";
    if (dateToken.length>=5) {
      const d = dateToken.slice(0,2);
      const m = months[dateToken.slice(2,5).toUpperCase()]||"??";
      const y = dateToken.length===7 ? "20"+dateToken.slice(5) : "2025";
      formattedDate = `${d}.${m}.${y}`;
    }

    // –º–∞—Ä—à—Ä—É—Ç
    let routeToken = toks.find(t=>/^[A-Z–ê-–Ø–Å]{6,8}$/i.test(t))||"";
    if (!routeToken) {
      const idx = toks.findIndex((t,i)=>aliasMap[t]&&aliasMap[toks[i+1]]);
      if (idx>=0) routeToken = toks[idx]+toks[idx+1];
    }
    // –µ—Å–ª–∏ –∫ –º–∞—Ä—à—Ä—É—Ç—É –ø—Ä–∏—Ü–µ–ø–∏–ª–∏ —Å—Ç–∞—Ç—É—Å
    for (let sc in statuses) {
      if (routeToken.endsWith(sc)) {
        const pure = routeToken.slice(0,-sc.length);
        const f = pure.slice(0,3), t = pure.slice(3);
        if ((aliasMap[f]||airports[f]) && (aliasMap[t]||airports[t])) {
          routeToken = pure;
          toks[toks.indexOf(sc)!==-1? toks.indexOf(sc):0] = pure;
          toks.push(sc);
          break;
        }
      }
    }
    const [fromCode,toCode] = matchRoute(isCyrillic(routeToken)
      ? normalizeCyrillic(routeToken) : routeToken);
    const from = airports[fromCode], to = airports[toCode];

    // –≤—Ä–µ–º—è
    const times = toks.map(t=>t.match(/\d{4}$/)?t.match(/\d{4}$/)[0]:null)
                     .filter(Boolean);
    let dep = times[times.length-2]||"", arr = times[times.length-1]||"";
    if (dep.length===4) dep = dep.slice(0,2)+":"+dep.slice(2);
    if (arr.length===4) arr = arr.slice(0,2)+":"+arr.slice(2);

    // ---- —É–ø—Ä–æ—â—ë–Ω–Ω—ã–π –ø–æ–∏—Å–∫ —Å—Ç–∞—Ç—É—Å–∞ ----
    const statusToken = toks.find(t=>statuses[t]);
    const status = statuses[statusToken]||"";

    console.log("route:",routeToken,"from",fromCode,"to",toCode,"st",statusToken);

    if (airline&&flight&&from&&to&&dep&&arr&&formattedDate) {
      out.push(`${airline}-${flight} ${formattedDate}, `
        +`${from.city} ${from.iata} ${dep} ‚Äî `
        +`${to.city} ${to.iata} ${arr}`
        +(status? " ‚Äî "+status:"")
      );
    } else {
      out.push("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Å—Ç—Ä–æ–∫—É: "+line);
    }
  }
  document.getElementById("output").textContent = out.join("\n");
}

function copyResult() {
  navigator.clipboard.writeText(document.getElementById("output").textContent);
}
function clearAll() {
  document.getElementById("input").value = "";
  document.getElementById("output").textContent = "";
}

init();
</script>
</body>
</html>
