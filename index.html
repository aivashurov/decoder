<!DOCTYPE html>

<html lang="ru">
<head>
<meta charset="utf-8"/>
<title>–î–µ—à–∏—Ñ—Ä–æ–≤—â–∏–∫ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π 2.0</title>
<style>
    /* –û–±—â–∏–µ —Å—Ç–∏–ª–∏ */
    *, *::before, *::after { box-sizing: border-box; }
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      max-width: 800px;
      margin: auto;
      color: #333;
    }
    h2 { margin-top: 0; }
    textarea, pre, .refresh-info {
      width: 100%;
      background: #fafafa;
      padding: 16px;
      border: 1px solid #ddd;
      border-radius: 6px;
      margin-top: 20px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
      font-size: 14px;
      color: #333;
    }
    textarea {
      height: 150px;
      font-family: monospace;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
      color: #000;
    }
    pre {
      white-space: pre-wrap;
      color: #000;
      margin-top: 10px;
    }

    /* –ö–Ω–æ–ø–∫–∏ */
    button { margin: 4px 2px; padding: 8px 16px; background: none; border: none; border-radius: 4px; color: inherit; font-size: 14px; cursor: pointer; transition: background 0.2s, transform 0.1s; }
    button:hover { background: rgba(0,0,0,0.05); }
    button:active { transform: translateY(0); }
    .action-btn { border: 1px solid #ccc; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .action-btn:hover { box-shadow: 0 2px 6px rgba(0,0,0,0.15); }

    /* –ë–ª–æ–∫ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è */
    .refresh-info ul { margin: 8px 0 12px; padding-left: 20px; list-style: disc outside; }
    .refresh-info kbd { display: inline-block; background: #e9ecef; border: none; border-radius: 4px; padding: 2px 6px; font-family: monospace; font-size: 13px; margin: 0 2px; }
    .refresh-info em { color: #555; font-style: italic; }

    /* –¢—ë–º–Ω–∞—è —Ç–µ–º–∞ */
    body.dark-mode { background: #121212; color: #eee; }
    body.dark-mode textarea, body.dark-mode pre {
      background: #1e1e1e;
      color: #fff;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.5);
      border: 1px solid #444;
    }
    body.dark-mode button { color: #eee; }
    body.dark-mode .action-btn { border-color: #444; box-shadow: 0 1px 3px rgba(0,0,0,0.5); }
    body.dark-mode .action-btn:hover { box-shadow: 0 2px 6px rgba(0,0,0,0.7); }
    body.dark-mode .refresh-info {
      background: #1e1e1e;
      color: #ddd;
      border: 1px solid #444;
    }
    body.dark-mode .refresh-info kbd { background: #333; color: #eee; }

    /* –ö–Ω–æ–ø–∫–∞ —Ç–µ–º—ã */
    .dark-toggle { position: absolute; top: 10px; right: 10px; padding: 6px 10px; border: 1px solid #666; border-radius: 6px; background: #333; color: #eee; cursor: pointer; }
    body.transition, body.transition * { transition: background-color 0.3s ease, color 0.3s ease; }
  </style>
</head>
<body>
<button class="dark-toggle" id="theme-toggle" onclick="toggleDarkMode()">üåô –¢—ë–º–Ω–∞—è —Ç–µ–º–∞</button>
<script>
    function toggleDarkMode() {
      document.body.classList.add('transition');
      document.body.classList.toggle('dark-mode');
      const btn = document.getElementById('theme-toggle');
      btn.textContent = document.body.classList.contains('dark-mode') ? '‚òÄÔ∏è –°–≤–µ—Ç–ª–∞—è —Ç–µ–º–∞' : 'üåô –¢—ë–º–Ω–∞—è —Ç–µ–º–∞';
      localStorage.setItem('theme', document.body.classList.contains('dark-mode') ? 'dark' : 'light');
      setTimeout(() => document.body.classList.remove('transition'), 300);
    }
    window.addEventListener('DOMContentLoaded', () => {
      if (localStorage.getItem('theme') === 'dark') {
        document.body.classList.add('dark-mode');
        document.getElementById('theme-toggle').textContent = '‚òÄÔ∏è –°–≤–µ—Ç–ª–∞—è —Ç–µ–º–∞';
      }
    });
  </script>
<h2>–î–µ—à–∏—Ñ—Ä–æ–≤—â–∏–∫ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π 2.0</h2>
<div style="margin: 10px 0;">
<label><input checked="" name="mode" onchange="changeMode(this.value)" type="radio" value="gds"/> GDS</label>
<label><input name="mode" onchange="changeMode(this.value)" type="radio" value="ndc"/> NDC</label>
</div>

<textarea id="input" placeholder="–í—Å—Ç–∞–≤—å —Å–∏—Å—Ç–µ–º–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ"></textarea><br/>
<button class="action-btn" onclick="decode()">–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
<button class="action-btn" onclick="copyResult()">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
<button class="action-btn" onclick="clearAll()">–û—á–∏—Å—Ç–∏—Ç—å</button>
<pre id="output"></pre>
<div class="refresh-info">
<p><strong>–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–µ?</strong> –ü–æ–ø—Ä–æ–±—É–π –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É:</p>
<ul>
<li><strong>Windows:</strong> <kbd>Ctrl+R</kbd> / <kbd>Ctrl+F5</kbd></li>
<li><strong>macOS:</strong> <kbd>‚åò+R</kbd> / <kbd>‚åò+Shift+R</kbd></li>
</ul>
<p><em>–†–∞–±–æ—Ç–∞–µ—Ç –≤ Chrome, Firefox, Edge –∏ Safari.</em></p>
</div>
<script>
    let airports = {}, aliasMap = {}, statuses = {};

    function isCyrillic(s) { return /[–ê-–Ø–Å–∞-—è—ë]/.test(s); }
    function transliterateCyrillic(s) {
      const map = {
        '–ê':'A','–ë':'B','–í':'V','–ì':'G','–î':'D','–ï':'E','–Å':'YO','–ñ':'ZH','–ó':'Z','–ò':'I','–ô':'Y',
        '–ö':'K','–õ':'L','–ú':'M','–ù':'N','–û':'O','–ü':'P','–†':'R','–°':'S','–¢':'T','–£':'U','–§':'F',
        '–•':'X','–¶':'TS','–ß':'CH','–®':'SH','–©':'SHCH','–´':'Y','–≠':'E','–Æ':'YU','–Ø':'YA'
      };
      return [...s].map(ch => map[ch]||ch).join('');
    }
    function normalizeToken(s) {
      const up = s.toUpperCase();
      return isCyrillic(up) ? transliterateCyrillic(up) : up;
    }

    function fetchCSV(url) {
      return fetch(url)
        .then(r => r.text())
        .then(text => {
          const [h, ...rows] = text.trim().split(/\r?\n/);
          const keys = h.split(',');
          return rows.map(r => {
            const vals = r.split(',');
            let obj = {};
            keys.forEach((k, i) => obj[k.trim()] = vals[i]?.trim() || "");
            return obj;
          });
        });
    }

    function init() {
      Promise.all([
        fetchCSV('https://raw.githubusercontent.com/aivashurov/decoder/main/airports_cleaned.csv?v='+Date.now()),
        fetchCSV('https://raw.githubusercontent.com/aivashurov/decoder/main/statuses_cleaned.csv?v='+Date.now())
      ]).then(([ad, sd]) => {
        ad.forEach(a => {
          airports[a.code] = { city: capitalize(a.city), iata: a.iata };
          if (a.alias) {
            a.alias.split(' ').filter(x => x).forEach(al => aliasMap[al.toUpperCase()] = a.code);
          }
        });
        sd.forEach(s => statuses[s.code.toUpperCase()] = s.description);
      }).catch(e => document.getElementById('output').textContent = '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ' + e);
    }

    function capitalize(s) {
      return s ? s.split(/([ -])/).map(w => /^[–ê-–Ø–ÅA-Z]/i.test(w) ? w[0].toUpperCase() + w.slice(1) : w).join('') : '';
    }

    function matchRoute(tok) {
      for (let len = 3; len <= 4; len++) {
        const f = tok.slice(0, len), t = tok.slice(len);
        const from = airports[f] ? f : aliasMap[f] || null;
        const to   = airports[t] ? t : aliasMap[t] || null;
        if (from && to) return [from, to];
      }
      return [null, null];
    }

    function findAirports(tokens) {
      // —Å–Ω–∞—á–∞–ª–∞ —Å–ª–∏—Ç–Ω—ã–µ TOKENS (6‚Äì8 –±—É–∫–≤), –ø–æ—Ç–æ–º –ø–∞—Ä—ã
      for (const t of tokens) {
        const letters = t.replace(/[^A-Za-z–Ä-”ø]/g, '');
        if (letters.length >= 6 && letters.length <= 8) {
          for (let i = 3; i <= letters.length - 3; i++) {
            const p1 = letters.slice(0, i), p2 = letters.slice(i);
            let from = isCyrillic(p1) ? aliasMap[p1.toUpperCase()] : (airports[p1.toUpperCase()] ? p1.toUpperCase() : aliasMap[p1.toUpperCase()]);
            let to   = isCyrillic(p2) ? aliasMap[p2.toUpperCase()] : (airports[p2.toUpperCase()] ? p2.toUpperCase() : aliasMap[p2.toUpperCase()]);
            if (from && to) return { from, to };
          }
        }
      }
      for (let i = 0; i < tokens.length - 1; i++) {
        const a = tokens[i].replace(/[^A-Za-z–Ä-”ø]/g,''), b = tokens[i+1].replace(/[^A-Za-z–Ä-”ø]/g,'');
        if (!a || !b) continue;
        let from = isCyrillic(a) ? aliasMap[a.toUpperCase()] : (airports[a.toUpperCase()] ? a.toUpperCase() : aliasMap[a.toUpperCase()]);
        let to   = isCyrillic(b) ? aliasMap[b.toUpperCase()] : (airports[b.toUpperCase()] ? b.toUpperCase() : aliasMap[b.toUpperCase()]);
        if (from && to) return { from, to };
      }
      return {};
    }

    // –æ–±–Ω–æ–≤–ª—ë–Ω–Ω–∞—è findFlight
    function findFlight(tokens) {
      for (const t of tokens) {
        const raw = t.replace(/^-/, '');
        const tok = normalizeToken(raw).replace(/[_ ]/g, '-');
        // –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —è–≤–Ω—ã–µ —Å—Ç–∞—Ç—É—Å—ã –∏ —á–∏—Å—Ç–æ —Ü–∏—Ñ—Ä—ã
        if (statuses[raw.toUpperCase()] || statuses[tok] || /^\d{3,4}$/.test(tok)) continue;
        if (!/^[A-Z0-9-]+$/.test(tok)) continue;
        const m = tok.match(/^([A-Z0-9]{2})-?(\d{1,4}[A-Z]?)$/i);
        if (m && /[A-Z]/.test(m[1])) {
          const airline = m[1].toUpperCase(), flight = m[2];
          const parts = raw.split(/[- ]/);
          return { airline, flight, rawAirline: parts[0], rawFlight: parts[1] || parts[0].slice(2) };
        }
      }
      // –µ—Å–ª–∏ —Å–ª–∏—Ç–Ω–æ–≥–æ –Ω–µ –Ω–∞—à–ª–∏ ‚Äî –¥–≤–∞ —Å–æ—Å–µ–¥–Ω–∏—Ö —Ç–æ–∫–µ–Ω–∞
      for (let i = 0; i < tokens.length - 1; i++) {
        const a = tokens[i].replace(/^-/, ''), b = tokens[i+1].replace(/^-/, '');
        const an = normalizeToken(a), bn = normalizeToken(b);
        if (!/^[A-Z0-9]{2}$/.test(an) || !/[A-Z]/.test(an) || !/^[0-9]{1,4}[A-Z]?$/.test(bn)) continue;
        return { airline: an, flight: bn, rawAirline: a, rawFlight: b };
      }
      return {};
    }

    function findDate(tokens) {
      const M = {
        "–Ø–ù–í":"01","–§–ï–í":"02","–ú–ê–†":"03","–ê–ü–†":"04","–ú–ê–ô":"05","–ò–Æ–ù":"06","–ò–Æ–õ":"07","–ê–í–ì":"08","–°–ï–ù":"09","–û–ö–¢":"10","–ù–û–Ø":"11","–î–ï–ö":"12",
        "JAN":"01","FEB":"02","MAR":"03","APR":"04","MAY":"05","JUN":"06","JUL":"07","AUG":"08","SEP":"09","OCT":"10","NOV":"11","DEC":"12"
      };
      for (const t of tokens) {
        const u = t.toUpperCase().replace(/[.,]/g, '');
        const m = u.match(/^(\d{2})([A-Z–ê-–Ø–Å]{3})(\d{2})?$/);
        if (m) {
          const [d, mo, yy] = [m[1], m[2], m[3]];
          return { raw: u, formatted: `${d}.${M[mo]||'??'}.${yy? '20'+yy : '2025'}` };
        }
      }
      return null;
    }

    // –æ–±–Ω–æ–≤–ª—ë–Ω–Ω–∞—è findStatus –±–µ–∑ —Ñ–∏–ª—å—Ç—Ä–∞ –ø–æ —Ü–∏—Ñ—Ä–∞–º
function findStatus(tokens, airlineCode) {
  const norm = tokens
    .map(t => t.toUpperCase().replace(/[_\s-]/g, ''))
    // –≤—ã–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ —Ç–æ–∫–µ–Ω—ã, —á—Ç–æ –µ—Å—Ç—å –≤ statuses –∏ –Ω–µ —Ä–∞–≤–Ω—ã –∫–æ–¥—É –∞–≤–∏–∞–∫–æ–º–ø–∞–Ω–∏–∏
    .filter(code => code !== airlineCode && statuses[code]);
  if (!norm.length) return '';
  // –µ—Å–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ, –±–µ—Ä—ë–º —Å–∞–º—ã–π –¥–ª–∏–Ω–Ω—ã–π (—á—Ç–æ–±—ã –Ω–µ –æ–±—Ä–µ–∑–∞—Ç—å, –Ω–∞–ø—Ä–∏–º–µ—Ä, OK25 vs OK)
  norm.sort((a, b) => b.length - a.length);
  return statuses[norm[0]];
}


    function findTimes(tokens, dt) {
      const year = dt ? dt.formatted.split('.')[2] : '';
      const rawTimes = tokens
        .map(t => t.match(/^(\d{4})$/))
        .filter(m => m)
        .map(m => m[1]);
      const filtered = rawTimes.filter(t => t !== year);
      let times = rawTimes.length >= 2
        ? (filtered.length >= 2 ? filtered : rawTimes)
        : filtered;
      if (times.length >= 2) {
        return {
          dep: times[times.length-2].slice(0,2) + ':' + times[times.length-2].slice(2),
          arr: times[times.length-1].slice(0,2) + ':' + times[times.length-1].slice(2)
        };
      } else if (times.length === 1) {
        return { dep: times[0].slice(0,2) + ':' + times[0].slice(2) };
      }
      return {};
    }

    function decode() {
      const lines = preprocessGDS(input.value.trim()).split(/\n+/);
      const out = [];
      for (const line of lines) {
        const tokens = line.trim().split(/\s+/).filter(x => x && !/^[.,*]$/.test(x));
        const fl = findFlight(tokens);
        const dt = findDate(tokens);
        const tm = findTimes(tokens, dt);
        const ap = findAirports(tokens);
        const st = findStatus(tokens, fl.airline);

        if (fl.airline && fl.flight && ap.from && ap.to && tm.dep) {
          const A = airports[ap.from], B = airports[ap.to];
          let r = `${fl.rawAirline}-${fl.rawFlight}`;
          if (dt) r += ` ${dt.formatted}`;
          r += dt ? ', ' : ' ';
          r += tm.arr
            ? `${A.city} ${A.iata} ${tm.dep} ‚Äî ${B.city} ${B.iata} ${tm.arr}`
            : `${A.city} ${A.iata} ${tm.dep} ‚Äî ${B.city} ${B.iata}`;
          if (st) r += ` ‚Äî ${st}`;
          out.push(r);
        } else {
          out.push(`‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Å—Ç—Ä–æ–∫—É: ${line}`);
        }
      }
      output.textContent = out.join('\n');
    }

    function preprocessGDS(l) {
      return l
        .replace(/[.,#]/g, '')
        .replace(/\s+O\*/g, '')
        .replace(/\s+E\b/g, '')
        .replace(/\b([A-Z0-9]{2})(\d{3,4}[A-Z]?)\b/g, '$1-$2');
    }

    function copyResult() { navigator.clipboard.writeText(output.textContent); }
    function clearAll()    { input.value = ''; output.textContent = ''; }

    // –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ
    init();
  


let decodeMode = 'gds';
function changeMode(mode) {
  decodeMode = mode;
}
const originalDecode = decode;
decode = function() {
  const raw = input.value.trim();
  if (decodeMode === 'ndc') return decodeNDC(raw);
  originalDecode();
};
function decodeNDC(text) {
  const blocks = text.split(/\n{2,}/);
  const out = [];

  // –º–∞–ø–ø–∏–Ω–≥ —Ä—É—Å—Å–∫–∏—Ö –º–µ—Å. –≤ —á–∏—Å–ª–∞
  const monthMap = {
    '—è–Ω–≤':1, '—Ñ–µ–≤':2, '–º–∞—Ä':3, '–∞–ø—Ä':4,
    '–º–∞–π':5, '–∏—é–Ω':6, '–∏—é–ª':7, '–∞–≤–≥':8,
    '—Å–µ–Ω':9, '–æ–∫—Ç':10,'–Ω–æ—è':11,'–¥–µ–∫':12
  };
  const currentYear = new Date().getFullYear();

  // —Ä–µ–≥—É–ª—è—Ä–∫–∏
  const flightRx   = /^[A-Z]{2,3}[-\s]?\d+/i;        // –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞: –∫–æ–¥+–Ω–æ–º–µ—Ä
  const dateRx     = /(\d{1,2})\s+([–ê-–Ø–∞-—è]{3})\.?/;  // "24 –∞–ø—Ä."
  const timeRx     = /^\d{2}:\d{2}$/;                // "00:40"
  const dayShiftRx = /\+(\d+)\s*–¥–Ω/i;                // "+1 –¥–µ–Ω—å"
  const iataRx     = /^[A-Z]{3}$/;                   // "OVB"
  const statusRx   = /^[A-Z]{2}$/;                   // "HK"

  for (const block of blocks) {
    const lines = block
      .trim()
      .split(/\n/)
      .map(l => l.trim())
      .filter(Boolean);

    // –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ª—é–±—ã–µ ¬´–±–ª–æ–∫–∏¬ª –±–µ–∑ —Ä–µ–π—Å–∞
    if (!flightRx.test(lines[0])) continue;

    // 1) –Ω–æ–º–µ—Ä —Ä–µ–π—Å–∞ –∏ –∞–≤–∏–∞–∫–æ–º–ø–∞–Ω–∏—è
    const [airline, flight] = lines[0].split(/\s+/);

    // 2) –¥–∞—Ç–∞: –∏—â–µ–º —Å—Ä–µ–¥–∏ —Å—Ç—Ä–æ–∫
    let dateStr = '';
    const dateLine = lines.find(l => dateRx.test(l));
    if (dateLine) {
      const [, d, mon] = dateLine.match(dateRx);
      const mm = monthMap[mon.toLowerCase()];
      dateStr = ` ${String(d).padStart(2,'0')}.${String(mm).padStart(2,'0')}.${currentYear}`;
    }

    // —Ç–æ–∫–µ–Ω—ã –≤—Å–µ–≥–æ –±–ª–æ–∫–∞
    const tokens = lines.flatMap(l => l.split(/\s+/));

    // 3) –≤—Ä–µ–º–µ–Ω–∞ –≤—ã–ª–µ—Ç–∞/–ø—Ä–∏–ª—ë—Ç–∞
    const times = tokens.filter(t => timeRx.test(t));
    if (times.length < 2) {
      out.push(`‚ö†Ô∏è –ù–µ –Ω–∞–π–¥–µ–Ω—ã –¥–≤–∞ –≤—Ä–µ–º–µ–Ω–∏ –≤ –±–ª–æ–∫–µ:\n${block}`);
      continue;
    }
    const [depTime, arrTime] = times;

    // 4) +N –¥–µ–Ω—å
    const ds = tokens.find(t => dayShiftRx.test(t));
    const dayShift = ds ? ` (+${ds.match(dayShiftRx)[1]})` : '';

    // 5) —Å—Ç–∞—Ç—É—Å
    const rawStatus = tokens.find(t =>
      statusRx.test(t)
      && t.toUpperCase() !== airline.toUpperCase()
      && !iataRx.test(t)
    );
    const status = rawStatus ? findStatus(tokens, airline) : '';

    // 6) —Å—Ç—Ä–æ–∏–º —Å–µ–≥–º–µ–Ω—Ç (–∫–æ—Ä–æ—Ç–∫–∏–π –∏–ª–∏ –¥–ª–∏–Ω–Ω—ã–π)
    // 6a) –∫–æ—Ä–æ—Ç–∫–∏–π: –¥–≤–∞ IATA-–∫–æ–¥–∞
    const codes = tokens.filter(t => iataRx.test(t) && airports[t]);
    let segment;
    if (codes.length >= 2) {
      const [depCode, arrCode] = codes;
      segment = `${airports[depCode].city} (${depCode}) ${depTime}` +
                ` ‚Äî ${airports[arrCode].city} (${arrCode}) ${arrTime}${dayShift}`;
    } else {
      // 6b) –¥–ª–∏–Ω–Ω—ã–π: –∏—â–µ–º –ø–µ—Ä–≤—ã–µ –¥–≤–µ ¬´–≥–æ—Ä–æ–¥—Å–∫–∏–µ¬ª —Å—Ç—Ä–æ–∫–∏ –ø–æ—Å–ª–µ arrTime
      const arrIdx = lines.findIndex(l => timeRx.test(l) && l === arrTime);
      const cityCands = [];
      for (let i = arrIdx + 1; i < lines.length; i++) {
        const l = lines[i].replace(/,$/, '');
        // –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ—á–µ–≤–∏–¥–Ω–æ–µ ¬´–º—É—Å–æ—Ä–Ω–æ–µ¬ª
        if (/^–≤ –ø—É—Ç–∏/i.test(l))      continue;
        if (/^\+?\d+—á/i.test(l))     continue;
        if (/^Airbus|^Boeing/i.test(l)) continue;
        if (/^–ê—ç—Ä–æ—Ñ–ª–æ—Ç/i.test(l))    continue;
        cityCands.push(l);
        if (cityCands.length === 2) break;
      }
      if (cityCands.length < 2) {
        out.push(`‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–¥–µ–ª–∏—Ç—å –≥–æ—Ä–æ–¥–∞ –≤ –±–ª–æ–∫–µ:\n${block}`);
        continue;
      }
      const [depCity, arrCity] = cityCands;
      segment = `${depTime} ${depCity} ‚Äî ${arrTime} ${arrCity}${dayShift}`;
    }

    // 7) —Å–æ–±–∏—Ä–∞–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—É—é —Å—Ç—Ä–æ–∫—É
    let line = `${airline}-${flight}${dateStr} ${segment}`;
    if (status) line += ` ‚Äî ${status}`;
    out.push(line);
  }

  output.textContent = out.join('\n');
}

</script>
</body>
</html>
